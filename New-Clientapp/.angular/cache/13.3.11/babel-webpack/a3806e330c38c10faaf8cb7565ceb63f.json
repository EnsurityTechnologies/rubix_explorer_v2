{"ast":null,"code":"import { __decorate, __param } from 'tslib';\nimport { EventEmitter, ElementRef, NgZone, Inject, PLATFORM_ID, Input, Output, HostListener, Directive, NgModule } from '@angular/core';\nimport { CountUp } from 'countup.js';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nlet CountUpDirective = /*#__PURE__*/(() => {\n  let CountUpDirective = class CountUpDirective {\n    constructor(el, zone, platformId) {\n      this.el = el;\n      this.zone = zone;\n      this.platformId = platformId;\n      this.options = {};\n      this.reanimateOnClick = true;\n      this.complete = new EventEmitter();\n    } // Re-animate if preference is set.\n\n\n    onClick() {\n      if (this.reanimateOnClick) {\n        this.animate();\n      }\n    }\n\n    ngOnChanges(changes) {\n      // don't animate server-side (universal)\n      if (!isPlatformBrowser(this.platformId)) {\n        return;\n      }\n\n      if (changes.endVal && changes.endVal.currentValue !== undefined) {\n        if (this.previousEndVal !== undefined) {\n          this.options = Object.assign({}, this.options, {\n            startVal: this.previousEndVal\n          });\n        }\n\n        this.countUp = new CountUp(this.el.nativeElement, this.endVal, this.options);\n        this.animate();\n        this.previousEndVal = this.endVal;\n      }\n    }\n\n    animate() {\n      this.zone.runOutsideAngular(() => {\n        this.countUp.reset();\n        this.countUp.start(() => {\n          this.zone.run(() => {\n            this.complete.emit();\n          });\n        });\n      });\n    }\n\n  };\n\n  CountUpDirective.ɵfac = function CountUpDirective_Factory(t) {\n    return new (t || CountUpDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID));\n  };\n\n  CountUpDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: CountUpDirective,\n    selectors: [[\"\", \"countUp\", \"\"]],\n    hostBindings: function CountUpDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function CountUpDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n    },\n    inputs: {\n      options: \"options\",\n      reanimateOnClick: \"reanimateOnClick\",\n      endVal: [\"countUp\", \"endVal\"]\n    },\n    outputs: {\n      complete: \"complete\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([Input('countUp')], CountUpDirective.prototype, \"endVal\", void 0);\n\n  __decorate([Input()], CountUpDirective.prototype, \"options\", void 0);\n\n  __decorate([Input()], CountUpDirective.prototype, \"reanimateOnClick\", void 0);\n\n  __decorate([Output()], CountUpDirective.prototype, \"complete\", void 0);\n\n  __decorate([HostListener('click')], CountUpDirective.prototype, \"onClick\", null);\n\n  CountUpDirective = __decorate([__param(2, Inject(PLATFORM_ID))], CountUpDirective);\n  return CountUpDirective;\n})();\nlet CountUpModule = /*#__PURE__*/(() => {\n  let CountUpModule = class CountUpModule {};\n\n  CountUpModule.ɵfac = function CountUpModule_Factory(t) {\n    return new (t || CountUpModule)();\n  };\n\n  CountUpModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: CountUpModule\n  });\n  CountUpModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return CountUpModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CountUpModule, {\n    declarations: [CountUpDirective],\n    exports: [CountUpDirective]\n  });\n})();\n/*\n * Public API Surface of count-up\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CountUpDirective, CountUpModule }; //# sourceMappingURL=ngx-countup.js.map","map":null,"metadata":{},"sourceType":"module"}